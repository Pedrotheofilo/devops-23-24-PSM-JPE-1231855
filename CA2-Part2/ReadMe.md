# Class Assignment 2 - Part 2

## Introduction


The objective of this class assignment was to leverage personal repositories and employ a basic Gradle application to introduce new features. While the features themselves may appear straightforward, the overarching aim is to grasp the workings and functionality of a Gradle wrapper, as well as to modify the build.gradle file effectively.
The culmination of this assignment can be located [here](https://github.com/Pedrotheofilo/devops-23-24-PSM-JPE-1231855/tree/tut-basic-gradle).

## Table of Contents

1. [Getting Started](#Getting-started)
2. [Implementing Changes](#Implementing-Changes)
    - [Part 1: Adding the frontend plugin](#Part-1-Adding-the-frontend-plugin)
    - [Part 2: Adding the copyJar task](#Part-2-Adding-the-copyJar-task)
    - [Part 3: Adding the deleteWebpackFiles task](#Part-3-Adding-the-deleteWebpackFiles-task)
    - [Part 4: Merging the branches](#Part-4-Merging-the-branches)
3. [Issues](#Issues)
4. [Alternative implementation solution](#Alternative-implementation-solution)
5. [Final Remarks](#Final-Remarks)


## Getting Started

The first step is to create a new branch called "tut-basic-gradle" in the repository to work on the assignment. To do so, open a git bash and type in the command:
```bash
git branch tut-basic-gradle
```

After creating the branch, switch to it by typing:
```bash
git checkout tut-basic-gradle
```

1. Go to [this website](https://start.spring.io) to generate a new gradle spring boot project. Fill in the necessary information and add the needed dependencies according to the image below:
2. Click on the "Generate" button and download the project. Extract the files to the CA2 Part2 folder.
3. Open the project in IntelliJ and delete de **src** folder.
4. Copy the **src** folder from Class Assignment 1 Part 1 to the project folder.
5. Copy the **webpack.config.js** and the **package.json** files from Class Assignment 1 Part 1 to the project folder.
6. Delete the **src/main/resources/static/built/** folder.
7. In the **Employee.java** class, change all *javax.persistence* imports to *jakarta.persistence*.
8. Add all te files to the staging area:
```bash
git add .
```
9. Commit the changes:
```bash
git commit -m "Deleted the src folder and copy the new src folder"
```
10. Push the changes to the repository:
```bash
git push
```

## Implementing Changes
### Part 1: Adding the frontend plugin

For this first section, the goal is to add a frontend plugin to our gradle project. The steps to do so are:

1. Open the build.gradle file and add the plugin:
```gradle
 id "org.siouan.frontend-jdk17" version "8.0.0"
```

2. Configure the plugin in the same build.gradle file:
```gradle
 frontend {
nodeVersion = "16.20.2"
assembleScript = "run build"
cleanScript = "run clean"
checkScript = "run check"
}
```

3. Add the dependencies in the build.gradle file:
```gradle
"scripts": {
"webpack": "webpack",
"build": "npm run webpack",
"check": "echo Checking frontend",
"clean": "echo Cleaning frontend",
"lint": "echo Linting frontend",
"test": "echo Testing frontend"
},
```
4. Add the package manager to the build.gradle file, before the scripts section:
```gradle
"packageManager": "npm@9.6.7",
```

5. Compile the project in the terminal(first navigate to the project folder):
```bash
./gradlew build
```
6. Now execute the application by using:
```bash
./gradlew bootRun```

7.  Add all te files to the staging area:
```bash
git add .
```
8. Commit the changes:
```bash
git commit -m "added the gradle plugin in the project"
```
9. Push the changes to the repository:
```bash
git push
```
### Part 2: Adding the copyJar task

For this part of the assignment, a new task will be added to copy the generated Jar file. The steps to do so are:

1. Open the build.gradle file and add the task:
```gradle
task copyJar(type: Copy, dependsOn: build) {
	from 'build/libs/'
	into 'dist'
	include '*.jar'
}
```
2. Compile the project in the terminal(first navigate to the project folder):
```bash
./gradlew build
```
3. Add all te files to the staging area:
```bash
git add .
```
4. Commit the changes:
```bash
git commit -m "added task build.gradle"
```
5. Push the changes to the repository:
```bash
git push
```

### Part 3: Adding the deleteWebpackFiles task

For this part of the assignment, a new task will be added to delete the files generated by the webpack. The steps to do so are:

1. Open the build.gradle file and add the task:
```gradle
task deleteWebpackFiles(type: Delete) {
	delete 'src/main/resources/static/built'
}
```
2. Add the following command to make sure this task is executed automatically by the task *clean*:
```gradle
clean.dependsOn(deleteWebpackFiles)
```

3. Compile the project in the terminal(first navigate to the project folder):
```bash
./gradlew build
```
4. Add all te files to the staging area:
```bash
git add .
```
5. Commit the changes:
```bash
git commit -m "Added the deleteWebpackFiles task"
```
6. Push the changes to the repository:
```bash
git push
```
### Part 4: Merging the branches

Now we need to merge to the master branch. To do so, follow these steps:
1. Switch to the master branch:
```bash
git checkout main
```
2. Merge the tut-basic-gradle branch:
```bash
git merge --no-ff tut-basic-gradle
```
3. Push the changes to the repository:
```bash
git push
```

## Issues
During the development of the assignment, if any problems arose, is it possible to use the GitHub issues feature. Issues can be opened in the Github repository website. To open a new issue, follow these steps:

1. Create ReadMe CA2-Part2 #7:
   (https://github.com/Pedrotheofilo/devops-23-24-PSM-JPE-1231855/issues/7)
2. Delete the src folder and copy the src folder #8:
   (https://github.com/Pedrotheofilo/devops-23-24-PSM-JPE-1231855/issues/8)
3. Add the gradle plugin in the project; #9:
   (https://github.com/Pedrotheofilo/devops-23-24-PSM-JPE-1231855/issues/9)
4. Add a task to build.gradle #10:
   (https://github.com/Pedrotheofilo/devops-23-24-PSM-JPE-1231855/issues/10)
5. The issue can be assigned to someone, labeled, and commented on. It can also be closed when the problem is solved by associating it with a commit:
```bash
git commit -a -m "Fixes #1"
```
## Alternative implementation solution
An alternative solution to the assignment would be to use a different solution for the build automation tool. Instead of using Gradle, we could use Apache Ant.

1. Comparison with Gradle regarding build automation features:
   - Gradle is a build automation tool that provides a flexible and powerful build system for Java projects. It uses a Groovy-based DSL for defining build scripts and supports incremental builds, dependency management, and parallel execution of tasks. Gradle is widely used in the Java community and has a large ecosystem of plugins and integrations.
   - Apache Ant is a build automation tool that uses XML-based build scripts to define build tasks and dependencies. It is a lightweight and flexible tool that is widely used in the Java community. Ant provides a set of built-in tasks for compiling, testing, packaging, and deploying Java projects. Ant is known for its simplicity and ease of use, but it lacks some of the advanced features and capabilities of Gradle.

1.1. **Script-based**: Ant is primarily XML-based, where build scripts are written in XML format. This differs from Gradle's Groovy or Kotlin DSL. While XML can be more verbose, it offers simplicity and ease of understanding, especially for those familiar with HTML or other markup languages.
By following these steps, the assignment can be completed using Maven as the build automation tool instead of Gradle. This alternative solution provides a different approach to implementing the changes required for the assignment and demonstrates the flexibility of using different build automation tools for Java projects.

1.2. **Extensibility**: Ant allows for the creation of custom tasks using Java. These tasks can be integrated into the build process to provide additional functionality. Gradle also supports custom tasks but uses Groovy or Kotlin for scripting.

1.3. **Dependency Management**: Unlike Gradle or Maven, Ant doesn't have built-in dependency management. However, it can be integrated with Ivy, a separate dependency manager that works seamlessly with Ant. This adds flexibility in managing project dependencies.

1.4. **Community and Support**: Ant has been around for a long time and has a mature ecosystem with a significant user base. While not as trendy as Gradle, it still enjoys strong community support with plenty of resources available for learning and troubleshooting.

2. Description of how Ant could be used to achieve the same goals:
    - To use Apache Ant for the assignment, we would need to create an Ant build script that defines the tasks required to build, test, and package the Java project. The build script would include tasks for compiling Java source code, running tests, generating JAR files, and cleaning up build artifacts.
    - We would also need to define dependencies between tasks to ensure that they are executed in the correct order. For example, the JAR file generation task should depend on the compilation task to ensure that the compiled classes are included in the JAR file.
    - Ant build scripts are written in XML format and can be easily customized to meet the specific requirements of the project. We could define properties, targets, and tasks in the build script to automate the build process and achieve the same goals as using Gradle.
    - While Ant may not have the same level of sophistication as Gradle, it is a lightweight and flexible build automation tool that can be used effectively for Java projects. By creating a well-structured build script, we can automate the build process and achieve the desired outcomes for the assignment.

2.1. **Project Setup**: Similar to Maven, you would start by creating an XML build file (typically named build.xml) in the project's root directory. This file contains targets and tasks defining the build process.

2.2. **Build Targets**: Ant organizes tasks into targets, which represent specific build operations such as compilation, testing, packaging, etc. These targets can depend on each other, allowing for a customized build flow.

2.3. **Task Execution**: Ant tasks are executed sequentially, following the order specified in the build file. Tasks can perform a wide range of operations such as compiling code, copying files, running tests, and more

2.4. **Custom Tasks**: Ant allows developers to create custom tasks by extending the Task class provided by the Ant API. These tasks can encapsulate complex build logic and be reused across multiple projects.

3. **Implementation**:
   To implement this alternative solution using Ant, you would:

3.1. Create a build.xml file in the project's root directory.

3.2. Define targets and tasks in the build file to replicate the build process required for the assignment.

3.3. Utilize built-in Ant tasks or develop custom tasks using Java to add specific functionality.

3.4. Execute the build using Ant commands (**ant**, **ant compile**, **ant test**, etc.).



## Final Remarks
During the development of this assignment, we encountered challenges with the frontend plugin implementation. It didn't behave as anticipated, leading to compilation issues within the project. After thorough investigation, we identified the root cause and resolved it by integrating the package manager section into the build.gradle file.

Regrettably, attempting to build the project before incorporating the package manager resulted in the generation and addition of erroneous files, hindering the compilation process. Consequently, we had to reset the assignment, necessitating additional commits to rectify the situation.

Upon revisiting the process and integrating the package manager section, the project compiled flawlessly, and the frontend plugin operated as intended. We successfully implemented the copyJar and deleteWebpackFiles tasks, and subsequently merged the project into the master branch. With these adjustments, the assignment reached completion, and we promptly pushed the changes to the repository.